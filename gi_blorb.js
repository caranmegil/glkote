'use strict';

/* Blorb -- a Blorb file decoder for GlkOte
 * Designed by Andrew Plotkin <erkyrath@eblong.com>
 * <http://eblong.com/zarf/glk/glkote.html>
 *
 * Blorb.init(image, opts) -- ###
 *
 * Blorb.get_exec_chunk() -- ###
 *
 * Blorb.get_data_chunk(NUM) -- this finds the Data chunk of the
 *   given number from the Blorb file. The returned object looks like
 *   { data:[...], type:"..." } (where the type is TEXT or BINA).
 *   If there was no such chunk, or if the game was loaded from a non-
 *   Blorb file, this returns undefined.
 *
 * Blorb.get_metadata(FIELD) -- this returns a metadata field (a
 *   string) from the iFiction <bibliographic> section. If there is
 *   no such field, or if the game was loaded from a non-Blorb
 *   file, this returns undefined.
 *
 * Blorb.get_cover_pict() -- this returns the number of the image
 *   resource which contains the cover art. If there is no cover art,
 *   this returns undefined.
 *
 * Blorb.get_image_info(NUM) -- returns an object describing an image,
 *   or undefined.
 *
 * Blorb.get_debug_info() -- returns an array containing debug info,
 *   or null.
 *
 * Blorb.get_image_url(NUM) -- returns a URL describing an image, or
 *   undefined.
 */

/* All state is contained in BlorbClass. */
var BlorbClass = function() {

var inited = false;
var metadata = {}; /* Title, author, etc -- loaded from Blorb */
var coverimageres = undefined; /* Image resource number of the cover art */
var debug_info = null; /* gameinfo.dbg file -- loaded from Blorb */
var blorbchunks = {}; /* Indexed by "USE:NUMBER" -- loaded from Blorb */

/* Look through a Blorb file (provided as a byte array) and return the
   game file chunk (ditto). If no such chunk is found, returns null.
   The gamechunktype option should be 'ZCOD' or 'GLUL'.

   This also loads the IFID metadata into the metadata object, and
   caches DATA chunks where we can reach them later.
*/
function blorb_init(data, opts) {
    var format = null;
    var gamechunktype = null;
    if (opts) {
        format = opts.format;
        gamechunktype = opts.gamechunktype;
    }

    if (format == 'infomap') {
        /* This is the old-style map of image resources. (See the
           image_info_map option in gi_load.js, or resourcemap.js as
           generated by blorbtool.py.) */
        var chunkls = [];
        /* Map of { imagenum: { image, url, width, height, alttext } } */
        var pat_numeric = new RegExp('^[0-9]+$');
        for (var key in data) {
            /* Only consider keys that are simple integers. */
            if (!(''+key).match(pat_numeric)) {
                continue;
            }
            var chunk = Object.assign({}, data[key]);
            var usagenum = 1*key;
            if (chunk.image !== undefined && chunk.image != usagenum) {
                /* This is an error, but there's not much we can do except
                   ignore it. */
            }
            delete chunk.image;
            chunk.usage = 'pict';
            chunk.usagenum = usagenum;

            /* If separate width/height fields were provided, combine them
               into an imagesize object. */
            if (chunk.width !== undefined && chunk.height !== undefined) {
                chunk.imagesize = { width:chunk.width, height:chunk.height };
            }
            delete chunk.width;
            delete chunk.height;

            chunkls.push(chunk);
        }

        format = null;
        data = chunkls;
        /* Fall through to next case! */
    }
    
    if (!format) {
        /* An array of resources. */
        for (var obj of data) {
            var chunk = Object.assign({}, obj);
            var key = chunk.usage + ':' + chunk.usagenum;

            if (chunk.usage == 'pict' && chunk.coverimage) {
                if (coverimageres == null) {
                    coverimageres = chunk.usagenum;
                }
            }

            //### absolutize url?
            
            blorbchunks[key] = chunk;
        }
        
        inited = true;
        return;
    }

    if (format != 'array') {
        throw new Error('Blorb: unrecognized format');
    }

    var alttexts = {}; /* Indexed by "USE:NUMBER" */

    /* Blorb data in an array of bytes. */

    var image = data;
    var len = image.length;
    var ix;
    var rindex = [];
    var pos = 12;

    while (pos < len) {
        var chunktype = String.fromCharCode(image[pos+0], image[pos+1], image[pos+2], image[pos+3]);
        pos += 4;
        var chunklen = (image[pos+0] << 24) | (image[pos+1] << 16) | (image[pos+2] << 8) | (image[pos+3]);
        pos += 4;

        if (chunktype == "RIdx") {
            var npos = pos;
            var numchunks = (image[npos+0] << 24) | (image[npos+1] << 16) | (image[npos+2] << 8) | (image[npos+3]);
            npos += 4;
            for (ix=0; ix<numchunks; ix++) {
                var chunkusage = String.fromCharCode(image[npos+0], image[npos+1], image[npos+2], image[npos+3]);
                npos += 4;
                var chunknum = (image[npos+0] << 24) | (image[npos+1] << 16) | (image[npos+2] << 8) | (image[npos+3]);
                npos += 4;
                var chunkpos = (image[npos+0] << 24) | (image[npos+1] << 16) | (image[npos+2] << 8) | (image[npos+3]);
                npos += 4;
                rindex.push( { usage:chunkusage, num:chunknum, pos:chunkpos } );
            }
        }
        if (chunktype == "IFmd") {
            var arr = image.slice(pos, pos+chunklen);
            var dat = encode_utf8_text(arr);
            var met = $('<metadata>').html(dat);
            var bibels = met.find('bibliographic').children();
            if (bibels.length) {
                var el;
                for (ix=0; ix<bibels.length; ix++) {
                    el = bibels[ix];
                    metadata[el.tagName.toLowerCase()] = el.textContent;
                }
            }
        }
        if (chunktype == "Dbug") {
            /* Because this is enormous, we only save it if the option
               is set to use it. */
            if (all_options.debug_info_chunk) {
                var arr = image.slice(pos, pos+chunklen);
                debug_info = arr;
            }
        }
        if (chunktype == "Fspc") {
            var npos = pos;
            coverimageres = (image[npos+0] << 24) | (image[npos+1] << 16) | (image[npos+2] << 8) | (image[npos+3]);
        }
        if (chunktype == "RDes") {
            var npos = pos;
            var numentries = (image[npos+0] << 24) | (image[npos+1] << 16) | (image[npos+2] << 8) | (image[npos+3]);
            npos += 4;
            for (ix=0; ix<numentries; ix++) {
                var rdusage = String.fromCharCode.apply(this, image.slice(npos, npos+4));
                npos += 4;
                var rdnumber = (image[npos+0] << 24) | (image[npos+1] << 16) | (image[npos+2] << 8) | (image[npos+3]);
                npos += 4;
                var rdlen = (image[npos+0] << 24) | (image[npos+1] << 16) | (image[npos+2] << 8) | (image[npos+3]);
                npos += 4;
                var rdtext = encode_utf8_text(image.slice(npos, npos+rdlen));
                npos += rdlen;
                alttexts[rdusage+':'+rdnumber] = rdtext;
            }
        }

        pos += chunklen;
        if (pos & 1)
            pos++;
    }

    /* We don't want to retain the original Blorb image in memory; it's
       enormous. We'll split out the addressable chunks (those with
       usages) and retain those individually. Still enormous, but less
       so.

       (It's probably a waste to save the cover image -- that probably
       won't ever be used by the game. But it might be.) 
    */

    for (ix=0; ix<rindex.length; ix++) {
        var el = rindex[ix];
        pos = el.pos;
        var chunktype = String.fromCharCode(image[pos+0], image[pos+1], image[pos+2], image[pos+3]);
        pos += 4;
        var chunklen = (image[pos+0] << 24) | (image[pos+1] << 16) | (image[pos+2] << 8) | (image[pos+3]);
        pos += 4;

        //### blorbtype to type, blorbusage to usage
        el.type = chunktype;
        el.len = chunklen;
        el.content = null;

        /*###
        if (chunk.type == 'JPEG')
            img.type = 'jpeg';
        else if (chunk.type == 'PNG ')
            img.type = 'png';
        else
            img.type = '????';
        */
        /* Extract the alt-text, if available. */
        /*###
        var rdtext = alttexts['Pict:'+val];
        if (rdtext)
            img.alttext = rdtext;
        */
        
        if (chunktype == "FORM") {
            el.content = image.slice(pos-8, pos+chunklen);
        }
        else {
            el.content = image.slice(pos, pos+chunklen);
        }
        blorbchunks[el.usage+':'+el.num] = el; //###
    }

    inited = true;
}

function is_inited()
{
    return inited;
}

function get_library(val)
{
    /* This module doesn't rely on any others. */
    return null;
}
    
function get_exec_data()
{
    var chunk = blorbchunks['exec:0'];
    if (!chunk) {
        return null;
    }

    return chunk.content;
}
    
/* Return a metadata field, or undefined if there is no such field
   (or if no metadata was loaded).
*/
function get_metadata(val) {
    return metadata[val];
}

/* Return the resource number of the image resource containing the
   cover art, or null if not available.
*/
function get_cover_pict() {
    return coverimageres;
}

/* Return the gameinfo.dbg file (as an array of bytes), if it was
   loaded.
*/
function get_debug_info() {
    return debug_info;
}

/* Return information describing an image. This might be loaded from static
   data or from a Blorb file.
   
   The return value will be null or an object:
   { image:VAL, type:STRING, alttext:STRING, width:NUMBER, height:NUMBER }

   (The alttext and type may be absent if not supplied.)
*/
function get_image_info(val) {
    var chunk = blorbchunks['pict:'+val];
    if (!chunk) {
        return null;
    }
    
    /* Extract the image size, if we don't have it cached already.
       We could do this by creating an Image DOM element and measuring
       it, but that could be slow. Instead, we'll parse the PNG or
       JPEG data directly. It's easier than it sounds! */
    if (chunk.imagesize === undefined && chunk.content) {
        var imgsize = undefined;
        if (chunk.type == 'jpeg') {
            imgsize = find_dimensions_jpeg(chunk.content);
        }
        else if (chunk.type == 'png') {
            imgsize = find_dimensions_png(chunk.content);
        }
        if (imgsize) {
            chunk.imagesize = imgsize;
        }
    }
    
    var img = Object.assign({}, chunk); // copy
    img.image = val;
    if (chunk.imagesize) {
        img.width = chunk.imagesize.width;
        img.height = chunk.imagesize.height;
    }

    return img;
}

/* Return a URL representing an image. This might be loaded from static
   data or from a Blorb file.

   The return value will be null or a URL. It might be a "data:..." URL.
*/
function get_image_url(val) {
    var chunk = blorbchunks['pict:'+val];
    if (!chunk) {
        return null;
    }
    
    if (chunk.url) {
        return chunk.url;
    }
    if (chunk.dataurl) {
        return chunk.dataurl;
    }

    /* Convert content into a dataurl, if available. */
    var info = get_image_info(val);
    if (info && chunk.content) {
        var mimetype = 'application/octet-stream';
        if (chunk.type == 'jpeg')
            mimetype = 'image/jpeg';
        else if (chunk.type == 'png')
            mimetype = 'image/png';
        var b64dat = encode_base64(chunk.content);
        chunk.dataurl = 'data:'+mimetype+';base64,'+b64dat;
        return chunk.dataurl;
    }

    /* Can't find anything. */
    return null;
}

/* Return the Data chunk with the given number, or undefined if there
   is no such chunk. (This is used by the glk_stream_open_resource()
   functions.)
*/
function get_data_chunk(val) {
    var chunk = blorbchunks['data:'+val];
    if (!chunk)
        return null;

    //### move upstairs?
    var isbinary = false;
    if (chunk.blorbtype == 'FORM')
        isbinary = true;

    return { data:chunk.content, type:chunk.type, binary:isbinary };
}

/* Convert an array of numeric byte values into a base64 string. */
function encode_base64(image)
{
    /* There's a limit on how much can be piped into .apply() at a 
       time -- that is, JS interpreters choke on too many arguments
       in a function call. 16k is a conservative limit. */
    var blocks = [];
    var imglen = image.length;
    for (var ix = 0; ix < imglen; ix += 16384) {
        blocks.push(String.fromCharCode.apply(String, image.slice(ix, ix + 16384)));
    }
    
    return btoa(blocks.join(''));
};

/* Convert an array of numeric byte values (containing UTF-8 encoded text)
   into a string.
*/
function encode_utf8_text(arr) {
    var res = [];
    var ch;
    var pos = 0;

    while (pos < arr.length) {
        var val0, val1, val2, val3;
        if (pos >= arr.length)
            break;
        val0 = arr[pos];
        pos++;
        if (val0 < 0x80) {
            ch = val0;
        }
        else {
            if (pos >= arr.length)
                break;
            val1 = arr[pos];
            pos++;
            if ((val1 & 0xC0) != 0x80)
                break;
            if ((val0 & 0xE0) == 0xC0) {
                ch = (val0 & 0x1F) << 6;
                ch |= (val1 & 0x3F);
            }
            else {
                if (pos >= arr.length)
                    break;
                val2 = arr[pos];
                pos++;
                if ((val2 & 0xC0) != 0x80)
                    break;
                if ((val0 & 0xF0) == 0xE0) {
                    ch = (((val0 & 0xF)<<12)  & 0x0000F000);
                    ch |= (((val1 & 0x3F)<<6) & 0x00000FC0);
                    ch |= (((val2 & 0x3F))    & 0x0000003F);
                }
                else if ((val0 & 0xF0) == 0xF0) {
                    if (pos >= arr.length)
                        break;
                    val3 = arr[pos];
                    pos++;
                    if ((val3 & 0xC0) != 0x80)
                        break;
                    ch = (((val0 & 0x7)<<18)   & 0x1C0000);
                    ch |= (((val1 & 0x3F)<<12) & 0x03F000);
                    ch |= (((val2 & 0x3F)<<6)  & 0x000FC0);
                    ch |= (((val3 & 0x3F))     & 0x00003F);
                }
                else {
                    break;
                }
            }
        }
        res.push(ch);
    }

    return String.fromCharCode.apply(this, res);
}

/* Given a PNG file, extract its dimensions. Return a {width,height}
   object, or undefined on error. 
*/
function find_dimensions_png(arr) {
    var pos = 0;
    if (arr[0] != 0x89 || String.fromCharCode.apply(this, arr.slice(1,4)) != 'PNG') {
        //console.log('find_dimensions_png: PNG signature does not match');
        return undefined;
    }
    pos += 8;
    while (pos < arr.length) {
        var chunklen = (arr[pos+0] << 24) | (arr[pos+1] << 16) | (arr[pos+2] << 8) | (arr[pos+3]);
        pos += 4;
        var chunktype = String.fromCharCode.apply(this, arr.slice(pos,pos+4));
        pos += 4;
        if (chunktype == 'IHDR') {
            var res = {};
            res.width  = (arr[pos+0] << 24) | (arr[pos+1] << 16) | (arr[pos+2] << 8) | (arr[pos+3]);
            pos += 4;
            res.height = (arr[pos+0] << 24) | (arr[pos+1] << 16) | (arr[pos+2] << 8) | (arr[pos+3]);
            pos += 4;
            return res;
        }
        pos += chunklen;
        pos += 4; /* skip CRC */
    }

    //console.log('find_dimensions_png: no PNG header block found');
    return undefined;
}

/* Given a JPEG file, extract its dimensions. Return a {width,height}
   object, or undefined on error. 
*/
function find_dimensions_jpeg(arr) {
    var pos = 0;
    while (pos < arr.length) {
        if (arr[pos] != 0xFF) {
            //console.log('find_dimensions_jpeg: marker is not 0xFF');
            return undefined;
        }
        while (arr[pos] == 0xFF) 
            pos += 1;
        var marker = arr[pos];
        pos += 1;
        if (marker == 0x01 || (marker >= 0xD0 && marker <= 0xD9)) {
            /* marker type has no data */
            continue;
        }
        var chunklen = (arr[pos+0] << 8) | (arr[pos+1]);
        if (marker >= 0xC0 && marker <= 0xCF && marker != 0xC8) {
            if (chunklen < 7) {
                //console.log('find_dimensions_jpeg: SOF block is too small');
                return undefined;
            }
            var res = {};
            res.height = (arr[pos+3] << 8) | (arr[pos+4]);
            res.width  = (arr[pos+5] << 8) | (arr[pos+6]);
            return res;
        }
        pos += chunklen;
    }

    //console.log('find_dimensions_jpeg: no SOF marker found');
    return undefined;
}

/* End of Blorb namespace function. Return the object which will
   become the Blorb global. */
return {
    classname: 'Blorb',
    init: blorb_init,
    inited: is_inited,
    getlibrary: get_library,

    get_exec_data: get_exec_data,
    get_data_chunk: get_data_chunk,
    get_metadata: get_metadata,
    get_cover_pict: get_cover_pict,
    get_debug_info: get_debug_info,
    get_image_info: get_image_info,
    get_image_url: get_image_url
};

};

/* I'm breaking the rule about creating a predefined instance. This is
   only used by GiLoad, which always creates a new instance.
*/
// var Blorb = new BlorbClass();

// Node-compatible behavior
try { exports.BlorbClass = BlorbClass; } catch (ex) {};

/* End of Blorb library. */
